# write-a-lang

[英文地址ast类型](http://lisperator.net/pltut/parser/the-ast)

### 前言
------
在程序的世界里，你就是国王，所有的规则都是由你来指定。接下来所要做的事就是根据你刚才定义的规则实现你的代码。完成语言的解析与解释执行。下面实现类似Lisp语言。
> * 规定1 所有的语句都以 " ; "结尾。

> * 规定2 使用lambda来定义函数，然后将定义好的函数赋值给变量。类似于Python。

> * 规定3 " () "仅代表函数执行。

> * 规定4 所有的字符串都使用 " " 进行包裹。

### 字符串流的处理。
首先我们需要输入的字符串，获取该字符串之后对其进行处理，我们输入的字符串类似于以下
```
	`sum = lambda(a, b) {
		  #if (2.34 > 1) then 2.45 else 3.909;
		  a + b + 3 * 4 + 4 * 5 + 6;
		  a + 12;
		  123.001;
		};

		#hahahah

		string = "xxxxx        \\\\\\\\\'       ";
		print(string);

		print(sum(1, 2));
	`

```
我用最熟悉的JS去实现，尽可能使用es5语法。但 ` ` 操作符使用es6规范。

在inputStream里面我们需要一个指针pivot指向当前的字符的位置，提供peek函数获取该位置上的字符，提供next函数让指针指向下一个字符，同时获取该字符。使用peek不会影响pivot的指向，用于对当前字符进行判断。另外提供一个eof字符判断是否到达字符串的最末尾，用于结束指针移动。从inputStream里返回的是一个类似迭代器的对象，用于获取所有的字符。上述字符串返回s、u、m...

### 对字符流进行组装
所有的语言都是以token为单位进行解析，例如"{;,+}()if else sum * + 等等"。为了获取token，我们上一步获取的字符流还需要进一步加工组合。在这一步我们就是返回一个个组合，并把空白字符等无关元素剔除。这里有些转义字符需要保存。这一步需要调用上一步返回的类迭代器的api进行解析。
这一个函数也同样返回一个类迭代器对象。提供一个peek函数返回当前的token，提供一个next函数将指针移向下一个token。



